# OperatingSystems_Project2

There is one file called bank_sim.py. Simply run it in a python environment that has python 3.12 installed (I personally use pycharm), or you can run it in a terminal with python 3.12 installed. If you choose to run it in a terminal, use the command "python bank_sim.py" and it will run with the output the program produces. If you choose to run it in an IDE, you can just click the run button and it will output the bank simulation produces. Global variables and semaphores are declared at first, and all will be needed for both threads in the file. After this is done, main will be called, and it will initiate the teller with semaphore status and communicate it is ready to start. The bank will open to the customers, and the thread will start first by picking an action, and the pass the action to the customer and associate it with the ID. Once this is done, customer thread will start its trying to come in. This done by two semaphores who will restrict access to get into the bank. It is released after the customer gets into the bank. Once this is done, customer is added to a queue. Once inside the queue, it will check to see if there is a teller available by checking a semaphore. If the semaphore signals it is good to go, it will add the tellerid to a variable, store it as the assigned teller, and pop it from the queue. It will then say it is selecting a teller, told the select teller, and then introduces itself. It will then wake up teller by releasing the semaphore. The customer then asks the transaction, and then it is given to the teller. Customer thread will pause here for now, and then teller thread does its own thing. Teller will then see the received transaction, and if it is a withdraw, it will ask the manager for permission. It will acquire the manager semaphore, sleep for a second to simulate approval, and then get permission after the sleep by releasing it. It will then go to the safe, acquire it to make sure only two can be in there at a time, and then enter if it good to (For a deposit, it will instantly skip to this step and ignore withdraw sequence). Otherwise it will wait for one of the tellers to leave and instantly go in. It will then leave the safe by releasing it. It will tell the customer it is done, and signal it is done. The customer thread will take over again once it has acquired the signal it is finished, and it will leave the bank by releading the door semaphore. After the customer is done and left the bank, release a semaphore that shows it is done in the bank. The teller thread takes over again, acquiring the signal the customer is left. It then signals it is free again by releasing the semaphore. It will then pause the queue and decrement the remaining number of customers by one. If that reaches 0, set the bank as closed, release all the tellers, and then output the final log message. There are logs placed all over the threads, and it is a function that is called to output the actions to the terminal and a text file called output.txt. You can open it to see the results after, or just look in the terminal. 
